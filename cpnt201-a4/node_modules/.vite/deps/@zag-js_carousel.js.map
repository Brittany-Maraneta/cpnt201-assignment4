{
  "version": 3,
  "sources": ["../../@zag-js/anatomy/src/create-anatomy.ts", "../../@zag-js/dom-query/src/attrs.ts", "../../@zag-js/dom-query/src/constants.ts", "../../@zag-js/dom-query/src/is.ts", "../../@zag-js/dom-query/src/contains.ts", "../../@zag-js/dom-query/src/env.ts", "../../@zag-js/dom-query/src/event.ts", "../../@zag-js/dom-query/src/get-by-id.ts", "../../@zag-js/dom-query/src/sanitize.ts", "../../@zag-js/dom-query/src/get-by-text.ts", "../../@zag-js/dom-query/src/get-by-typeahead.ts", "../../@zag-js/dom-query/src/get-computed-style.ts", "../../@zag-js/dom-query/src/get-parent-node.ts", "../../@zag-js/dom-query/src/get-scroll-position.ts", "../../@zag-js/dom-query/src/is-editable-element.ts", "../../@zag-js/dom-query/src/is-hidden-element.ts", "../../@zag-js/dom-query/src/is-overflow-element.ts", "../../@zag-js/dom-query/src/overflow.ts", "../../@zag-js/dom-query/src/platform.ts", "../../@zag-js/dom-query/src/query.ts", "../../@zag-js/dom-query/src/raf.ts", "../../@zag-js/dom-query/src/scope.ts", "../../@zag-js/dom-query/src/scroll-into-view.ts", "../../@zag-js/utils/src/array.ts", "../../@zag-js/utils/src/equal.ts", "../../@zag-js/utils/src/functions.ts", "../../@zag-js/utils/src/guard.ts", "../../@zag-js/utils/src/object.ts", "../../@zag-js/utils/src/split-props.ts", "../../@zag-js/utils/src/warning.ts", "../../proxy-compare/src/index.ts", "../../@zag-js/store/src/proxy.ts", "../../@zag-js/store/src/proxy-computed.ts", "../../klona/full/index.mjs", "../../@zag-js/core/src/index.ts", "../../@zag-js/utilities/core/src/array.ts", "../../@zag-js/utilities/core/src/functions.ts", "../../@zag-js/utilities/core/src/guard.ts", "../../@zag-js/utilities/core/src/object.ts", "../../@zag-js/utilities/core/src/warning.ts", "../../@zag-js/core/src/deep-merge.ts", "../../@zag-js/core/src/utils.ts", "../../@zag-js/core/src/guard-utils.ts", "../../@zag-js/core/src/machine.ts", "../../@zag-js/core/src/create-proxy.ts", "../../@zag-js/core/src/delay-utils.ts", "../../@zag-js/core/src/transition-utils.ts", "../../@zag-js/core/src/merge-props.ts", "../../@zag-js/types/src/prop-types.ts", "../../@zag-js/types/src/create-props.ts", "../../@zag-js/carousel/src/carousel.anatomy.ts", "../../@zag-js/carousel/src/carousel.connect.ts", "../../@zag-js/carousel/src/carousel.dom.ts", "../../@zag-js/carousel/src/utils/get-limit.ts", "../../@zag-js/carousel/src/utils/get-alignment.ts", "../../@zag-js/carousel/src/utils/get-slide-groups.ts", "../../@zag-js/carousel/src/utils/get-slide-sizes.ts", "../../@zag-js/carousel/src/utils/get-scroll-snaps.ts", "../../@zag-js/carousel/src/utils/get-slide-in-view.ts", "../../@zag-js/carousel/src/carousel.machine.ts", "../../@zag-js/carousel/src/carousel.props.ts"],
  "sourcesContent": ["export interface AnatomyPart {\n  selector: string\n  attrs: Record<\"data-scope\" | \"data-part\", string>\n}\n\nexport type AnatomyInstance<T extends string> = Omit<Anatomy<T>, \"parts\">\n\nexport type AnatomyPartName<T> = T extends AnatomyInstance<infer U> ? U : never\n\nexport interface Anatomy<T extends string> {\n  parts: <U extends string>(...parts: U[]) => AnatomyInstance<U>\n  extendWith: <V extends string>(...parts: V[]) => AnatomyInstance<T | V>\n  build: () => Record<T, AnatomyPart>\n  rename: (newName: string) => Anatomy<T>\n  keys: () => T[]\n}\n\nexport const createAnatomy = <T extends string>(name: string, parts = [] as T[]): Anatomy<T> => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values)\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\")\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () =>\n    [...new Set(parts)].reduce<Record<string, AnatomyPart>>(\n      (prev, part) =>\n        Object.assign(prev, {\n          [part]: {\n            selector: [\n              `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n              `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n            ].join(\", \"),\n            attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) },\n          },\n        }),\n      {},\n    ),\n})\n\nconst toKebabCase = (value: string) =>\n  value\n    .replace(/([A-Z])([A-Z])/g, \"$1-$2\")\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/[\\s_]+/g, \"-\")\n    .toLowerCase()\n\nconst isEmpty = <T>(v: T[]): boolean => v.length === 0\n", "import type { Booleanish } from \"./types\"\n\nexport const dataAttr = (guard: boolean | undefined) => (guard ? \"\" : undefined) as Booleanish\nexport const ariaAttr = (guard: boolean | undefined) => (guard ? \"true\" : undefined)\n", "export const MAX_Z_INDEX = 2147483647\n", "export const isHTMLElement = (v: any): v is HTMLElement =>\n  typeof v === \"object\" && v?.nodeType === Node.ELEMENT_NODE && typeof v?.nodeName === \"string\"\n\nexport const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport const isWindow = (el: any): el is Window => el != null && el === el.window\n\nexport const isVisualViewport = (el: any): el is VisualViewport =>\n  el != null && el.constructor.name === \"VisualViewport\"\n\nexport const getNodeName = (node: Node | Window): string => {\n  if (isHTMLElement(node)) return node.localName || \"\"\n  return \"#document\"\n}\n\nexport function isRootElement(node: Node): boolean {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node))\n}\n\nexport const isNode = (el: any): el is Node => el.nodeType !== undefined\n\nexport const isShadowRoot = (el: any): el is ShadowRoot =>\n  el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in el\n", "import { isHTMLElement } from \"./is\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n", "import { isHTMLElement, isDocument, isShadowRoot, isWindow } from \"./is\"\n\nexport function getDocument(el: Element | Window | Node | Document | null) {\n  if (isDocument(el)) return el\n  if (isWindow(el)) return el.document\n  return el?.ownerDocument ?? document\n}\n\nexport function getDocumentElement(el: Element | Node | Window | Document | null): HTMLElement {\n  return getDocument(el).documentElement\n}\n\nexport function getWindow(el: Node | ShadowRoot | Document | undefined) {\n  if (isShadowRoot(el)) return getWindow(el.host)\n  if (isDocument(el)) return el.defaultView ?? window\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window\n  return window\n}\n\nexport function getActiveElement(el: HTMLElement): HTMLElement | null {\n  const doc = getDocument(el)\n  let activeElement = doc.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n", "import { contains } from \"./contains\"\n\nexport function getBeforeInputValue(event: Pick<InputEvent, \"currentTarget\">) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget as HTMLInputElement\n  return value.slice(0, selectionStart!) + (event as any).data + value.slice(selectionEnd!)\n}\n\nexport function getEventTarget<T extends EventTarget>(event: Event): T | null {\n  return (event.composedPath?.()[0] ?? event.target) as T | null\n}\n\nexport const isSelfEvent = (event: Pick<UIEvent, \"currentTarget\" | \"target\">) =>\n  contains(event.currentTarget, event.target)\n", "export type ItemToId<T> = (v: T) => string\n\nexport const defaultItemToId = <T extends HTMLElement>(v: T) => v.id\n\nexport function itemById<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  const item = itemById(v, id, itemToId)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n", "export const sanitize = (str: string) =>\n  str\n    .split(\"\")\n    .map((char) => {\n      const code = char.charCodeAt(0)\n      if (code > 0 && code < 128) return char\n      if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\")\n      return \"\"\n    })\n    .join(\"\")\n    .trim()\n", "import { defaultItemToId, indexOfId, type ItemToId } from \"./get-by-id\"\nimport { sanitize } from \"./sanitize\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\")\n\nconst match = (valueText: string, query: string) => valueText.trim().toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(\n  v: T[],\n  text: string,\n  currentId?: string | null,\n  itemToId: ItemToId<T> = defaultItemToId,\n) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n", "import { getByText } from \"./get-by-text\"\nimport type { ItemToId } from \"./get-by-id\"\n\nexport interface TypeaheadState {\n  keysSoFar: string\n  timer: number\n}\n\nexport interface TypeaheadOptions {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n  itemToId?: ItemToId<HTMLElement>\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350, itemToId } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId, itemToId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n", "import { getWindow } from \"./env\"\n\nconst styleCache = new WeakMap<Element, CSSStyleDeclaration>()\n\nexport function getComputedStyle(el: Element) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el))\n  }\n  return styleCache.get(el)!\n}\n", "import { getDocumentElement } from \"./env\"\nimport { getNodeName, isShadowRoot } from \"./is\"\n\nexport function getParentNode(node: Node): Node {\n  if (getNodeName(node) === \"html\") {\n    return node\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as any).assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) ||\n    // Fallback.\n    getDocumentElement(node)\n\n  return isShadowRoot(result) ? result.host : result\n}\n", "import { isHTMLElement } from \"./is\"\n\nexport interface ScrollPosition {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function getScrollPosition(element: HTMLElement | Window): ScrollPosition {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop }\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY }\n}\n", "import { getWindow } from \"./env\"\nimport { isHTMLElement } from \"./is\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = getWindow(el)\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n", "export function isHiddenElement(node: HTMLElement) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true\n  return node.hidden\n}\n", "import { getWindow } from \"./env\"\n\nconst OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/\n\nexport function isOverflowElement(el: HTMLElement): boolean {\n  const win = getWindow(el)\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el)\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display)\n}\n", "import { getDocument, getWindow } from \"./env\"\nimport { getParentNode } from \"./get-parent-node\"\nimport { isHTMLElement, isRootElement, isVisualViewport } from \"./is\"\nimport { isOverflowElement } from \"./is-overflow-element\"\n\nexport type OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getNearestOverflowAncestor(el: Node): HTMLElement {\n  const parentNode = getParentNode(el)\n\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode\n  }\n\n  return getNearestOverflowAncestor(parentNode)\n}\n\nexport function getOverflowAncestors(el: HTMLElement, list: OverflowAncestor = []): OverflowAncestor {\n  const scrollableAncestor = getNearestOverflowAncestor(el)\n  const isBody = scrollableAncestor === el.ownerDocument.body\n  const win = getWindow(scrollableAncestor)\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []))\n}\n\nconst getRect = (el: HTMLElement | Window | VisualViewport) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect()\n  }\n\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width }\n  }\n\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth }\n}\n\nexport function isInView(el: HTMLElement | Window | VisualViewport, ancestor: HTMLElement | Window | VisualViewport) {\n  if (!isHTMLElement(el)) return true\n\n  const ancestorRect = getRect(ancestor)\n  const elRect = el.getBoundingClientRect()\n\n  return (\n    elRect.top >= ancestorRect.top &&\n    elRect.left >= ancestorRect.left &&\n    elRect.bottom <= ancestorRect.bottom &&\n    elRect.right <= ancestorRect.right\n  )\n}\n", "export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice()\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => pt(/iP(hone|ad|od)|iOS/)\nexport const isWebKit = () => ua(/AppleWebKit/)\n", "type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector) ?? null\n}\n", "export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n", "import { getDocument } from \"./env\"\n\nexport interface ScopeContext {\n  getRootNode?(): Document | ShadowRoot | Node\n}\n\nexport function createScope<T>(methods: T) {\n  const screen = {\n    getRootNode: (ctx: ScopeContext) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: ScopeContext) => getDocument(screen.getRootNode(ctx)),\n    getWin: (ctx: ScopeContext) => screen.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: ScopeContext) => screen.getDoc(ctx).activeElement as HTMLElement | null,\n    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => elem === screen.getActiveElement(ctx),\n    getById: <T extends HTMLElement = HTMLElement>(ctx: ScopeContext, id: string) =>\n      screen.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      const valueAsString = value.toString()\n      if (elem.value === valueAsString) return\n      elem.value = value.toString()\n    },\n  }\n\n  return { ...screen, ...methods }\n}\n", "import { isOverflowElement } from \"./is-overflow-element\"\n\nexport interface ScrollOptions extends ScrollIntoViewOptions {\n  rootEl: HTMLElement | null\n}\n\nfunction isScrollable(el: HTMLElement): boolean {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth\n}\n\nexport function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void {\n  const { rootEl, ...scrollOptions } = options || {}\n\n  if (!el || !rootEl) {\n    return\n  }\n\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return\n  }\n\n  el.scrollIntoView(scrollOptions)\n}\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "const isArrayLike = (value: any) => value?.constructor.name === \"Array\"\n\nexport const isEqual = (a: any, b: any): boolean => {\n  if (Object.is(a, b)) return true\n\n  if ((a == null && b != null) || (a != null && b == null)) return false\n\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b)\n  }\n\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString()\n  }\n\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return Array.from(a).toString() === Array.from(b).toString()\n  }\n\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false\n\n  const keys = Object.keys(b ?? Object.create(null))\n  const length = keys.length\n\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i])\n    if (!hasKey) return false\n  }\n\n  for (let i = 0; i < length; i++) {\n    const key = keys[i]\n    if (!isEqual(a[key], b[key])) return false\n  }\n\n  return true\n}\n", "export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n", "type Dict = Record<string, any>\n\nexport function splitProps<T extends Dict>(props: T, keys: (keyof T)[]) {\n  const rest: Dict = {}\n  const result: Dict = {}\n\n  const keySet = new Set(keys)\n\n  for (const key in props) {\n    if (keySet.has(key)) {\n      result[key] = props[key]\n    } else {\n      rest[key] = props[key]\n    }\n  }\n\n  return [result, rest]\n}\n\nexport const createSplitProps = <T extends Dict>(keys: (keyof T)[]) => {\n  return function split<Props extends T>(props: Props) {\n    return splitProps(props, keys) as [T, Omit<Props, keyof T>]\n  }\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n\n// function to create a new bare proxy\nlet newProxy = <T extends object>(\n  target: T,\n  handler: ProxyHandler<T>,\n) => new Proxy(target, handler);\n\n// get object prototype\nconst getProto = Object.getPrototypeOf;\n\nconst objectsToTrack = new WeakMap<object, boolean>();\n\n// check if obj is a plain object or an array\nconst isObjectToTrack = <T>(obj: T): obj is T extends object ? T : never => (\n  obj && (objectsToTrack.has(obj as unknown as object)\n    ? objectsToTrack.get(obj as unknown as object) as boolean\n    : (getProto(obj) === Object.prototype || getProto(obj) === Array.prototype)\n  )\n);\n\n// check if it is object\nconst isObject = (x: unknown): x is object => (\n  typeof x === 'object' && x !== null\n);\n\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj: object) => (\n  Object.values(Object.getOwnPropertyDescriptors(obj)).some(\n    (descriptor) => !descriptor.configurable && !descriptor.writable,\n  )\n);\n\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = <T extends object>(obj: T): T => {\n  if (Array.isArray(obj)) {\n    // Arrays need a special way to copy\n    return Array.from(obj) as T;\n  }\n  // For non-array objects, we create a new object keeping the prototype\n  // with changing all configurable options (otherwise, proxies will complain)\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  Object.values(descriptors).forEach((desc) => { desc.configurable = true; });\n  return Object.create(getProto(obj), descriptors);\n};\n\ntype HasKeySet = Set<string | symbol>\ntype HasOwnKeySet = Set<string | symbol>\ntype KeysSet = Set<string | symbol>\ntype Used = {\n  [HAS_KEY_PROPERTY]?: HasKeySet;\n  [ALL_OWN_KEYS_PROPERTY]?: true;\n  [HAS_OWN_KEY_PROPERTY]?: HasOwnKeySet;\n  [KEYS_PROPERTY]?: KeysSet;\n};\ntype Affected = WeakMap<object, Used>;\ntype ProxyHandlerState<T extends object> = {\n  readonly [IS_TARGET_COPIED_PROPERTY]: boolean;\n  [PROXY_PROPERTY]?: T;\n  [PROXY_CACHE_PROPERTY]?: ProxyCache<object> | undefined;\n  [TARGET_CACHE_PROPERTY]?: TargetCache<object> | undefined;\n  [AFFECTED_PROPERTY]?: Affected;\n}\ntype ProxyCache<T extends object> = WeakMap<\n  object,\n  readonly [ProxyHandler<T>, ProxyHandlerState<T>]\n>;\ntype TargetCache<T extends object> = WeakMap<\n  object,\n  readonly [target: T, copiedTarget?: T]\n>;\n\nconst createProxyHandler = <T extends object>(origObj: T, isTargetCopied: boolean) => {\n  const state: ProxyHandlerState<T> = {\n    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n  };\n  let trackObject = false; // for trackMemo\n  const recordUsage = (\n    type:\n      | typeof HAS_KEY_PROPERTY\n      | typeof ALL_OWN_KEYS_PROPERTY\n      | typeof HAS_OWN_KEY_PROPERTY\n      | typeof KEYS_PROPERTY,\n    key?: string | symbol,\n  ) => {\n    if (!trackObject) {\n      let used = (state[AFFECTED_PROPERTY] as Affected).get(origObj);\n      if (!used) {\n        used = {};\n        (state[AFFECTED_PROPERTY] as Affected).set(origObj, used);\n      }\n      if (type === ALL_OWN_KEYS_PROPERTY) {\n        used[ALL_OWN_KEYS_PROPERTY] = true;\n      } else {\n        let set = used[type];\n        if (!set) {\n          set = new Set();\n          used[type] = set;\n        }\n        set.add(key as string | symbol);\n      }\n    }\n  };\n  const recordObjectAsUsed = () => {\n    trackObject = true;\n    (state[AFFECTED_PROPERTY] as Affected).delete(origObj);\n  };\n  const handler: ProxyHandler<T> = {\n    get(target, key) {\n      if (key === GET_ORIGINAL_SYMBOL) {\n        return origObj;\n      }\n      recordUsage(KEYS_PROPERTY, key);\n      return createProxy(\n        Reflect.get(target, key),\n        (state[AFFECTED_PROPERTY] as Affected),\n        state[PROXY_CACHE_PROPERTY],\n        state[TARGET_CACHE_PROPERTY],\n      );\n    },\n    has(target, key) {\n      if (key === TRACK_MEMO_SYMBOL) {\n        recordObjectAsUsed();\n        return true;\n      }\n      recordUsage(HAS_KEY_PROPERTY, key);\n      return Reflect.has(target, key);\n    },\n    getOwnPropertyDescriptor(target, key) {\n      recordUsage(HAS_OWN_KEY_PROPERTY, key);\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    },\n    ownKeys(target) {\n      recordUsage(ALL_OWN_KEYS_PROPERTY);\n      return Reflect.ownKeys(target);\n    },\n  };\n  if (isTargetCopied) {\n    handler.set = handler.deleteProperty = () => false;\n  }\n  return [handler, state] as const;\n};\n\nconst getOriginalObject = <T extends object>(obj: T) => (\n  // unwrap proxy\n  (obj as { [GET_ORIGINAL_SYMBOL]?: typeof obj })[GET_ORIGINAL_SYMBOL]\n  // otherwise\n  || obj\n);\n\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = <T>(\n  obj: T,\n  affected: WeakMap<object, unknown>,\n  proxyCache?: WeakMap<object, unknown>,\n  targetCache?: WeakMap<object, unknown>,\n): T => {\n  if (!isObjectToTrack(obj)) return obj;\n  let targetAndCopied = (\n    targetCache && (targetCache as TargetCache<typeof obj>).get(obj)\n  );\n  if (!targetAndCopied) {\n    const target = getOriginalObject(obj);\n    if (needsToCopyTargetObject(target)) {\n      targetAndCopied = [target, copyTargetObject(target)];\n    } else {\n      targetAndCopied = [target];\n    }\n    targetCache?.set(obj, targetAndCopied);\n  }\n  const [target, copiedTarget] = targetAndCopied;\n  let handlerAndState = (\n    proxyCache && (proxyCache as ProxyCache<typeof target>).get(target)\n  );\n  if (\n    !handlerAndState\n    || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget\n  ) {\n    handlerAndState = createProxyHandler<typeof target>(target, !!copiedTarget);\n    handlerAndState[1][PROXY_PROPERTY] = newProxy(\n      copiedTarget || target,\n      handlerAndState[0],\n    );\n    if (proxyCache) {\n      proxyCache.set(target, handlerAndState);\n    }\n  }\n  handlerAndState[1][AFFECTED_PROPERTY] = affected as Affected;\n  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache as ProxyCache<object> | undefined;\n  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache as TargetCache<object> | undefined;\n  return handlerAndState[1][PROXY_PROPERTY] as typeof target;\n};\n\nconst isAllOwnKeysChanged = (prevObj: object, nextObj: object) => {\n  const prevKeys = Reflect.ownKeys(prevObj);\n  const nextKeys = Reflect.ownKeys(nextObj);\n  return prevKeys.length !== nextKeys.length\n    || prevKeys.some((k, i) => k !== nextKeys[i]);\n};\n\ntype ChangedCache = WeakMap<object, {\n  [NEXT_OBJECT_PROPERTY]: object;\n  [CHANGED_PROPERTY]: boolean;\n}>;\n\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\n\nexport const isChanged = (\n  prevObj: unknown,\n  nextObj: unknown,\n  affected: WeakMap<object, unknown>,\n  cache?: WeakMap<object, unknown>,\n  isEqual: (a: unknown, b: unknown) => boolean = Object.is,\n): boolean => {\n  if (isEqual(prevObj, nextObj)) {\n    return false;\n  }\n  if (!isObject(prevObj) || !isObject(nextObj)) return true;\n  const used = (affected as Affected).get(getOriginalObject(prevObj));\n  if (!used) return true;\n  if (cache) {\n    const hit = (cache as ChangedCache).get(prevObj);\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    }\n    // for object with cycles\n    (cache as ChangedCache).set(prevObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: false,\n    });\n  }\n  let changed: boolean | null = null;\n  try {\n    for (const key of used[HAS_KEY_PROPERTY] || []) {\n      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n      if (changed) return changed;\n    }\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n      changed = isAllOwnKeysChanged(prevObj, nextObj);\n      if (changed) return changed;\n    } else {\n      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n        changed = hasPrev !== hasNext;\n        if (changed) return changed;\n      }\n    }\n    for (const key of used[KEYS_PROPERTY] || []) {\n      changed = isChanged(\n        (prevObj as any)[key],\n        (nextObj as any)[key],\n        affected,\n        cache,\n        isEqual,\n      );\n      if (changed) return changed;\n    }\n    if (changed === null) changed = true;\n    return changed;\n  } finally {\n    if (cache) {\n      cache.set(prevObj, {\n        [NEXT_OBJECT_PROPERTY]: nextObj,\n        [CHANGED_PROPERTY]: changed,\n      });\n    }\n  }\n};\n\n// explicitly track object with memo\nexport const trackMemo = (obj: unknown) => {\n  if (isObjectToTrack(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n  return false;\n};\n\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = <T>(obj: T): T | null => {\n  if (isObjectToTrack(obj)) {\n    return (obj as { [GET_ORIGINAL_SYMBOL]?: T })[GET_ORIGINAL_SYMBOL] || null;\n  }\n  return null;\n};\n\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj: object, mark = true) => {\n  objectsToTrack.set(obj, mark);\n};\n\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (\n  obj: unknown,\n  affected: WeakMap<object, unknown>,\n  onlyWithValues?: boolean,\n) => {\n  const list: (string | symbol)[][] = [];\n  const seen = new WeakSet();\n  const walk = (x: unknown, path?: (string | symbol)[]) => {\n    if (seen.has(x as object)) {\n      // for object with cycles\n      return;\n    }\n    if (isObject(x)) {\n      seen.add(x);\n    }\n    const used = isObject(x) && (affected as Affected).get(getOriginalObject(x));\n    if (used) {\n      used[HAS_KEY_PROPERTY]?.forEach((key) => {\n        const segment = `:has(${String(key)})`;\n        list.push(path ? [...path, segment] : [segment]);\n      });\n      if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        const segment = ':ownKeys';\n        list.push(path ? [...path, segment] : [segment]);\n      } else {\n        used[HAS_OWN_KEY_PROPERTY]?.forEach((key) => {\n          const segment = `:hasOwn(${String(key)})`;\n          list.push(path ? [...path, segment] : [segment]);\n        });\n      }\n      used[KEYS_PROPERTY]?.forEach((key) => {\n        if (!onlyWithValues || 'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n          walk((x as any)[key], path ? [...path, key] : [key]);\n        }\n      });\n    } else if (path) {\n      list.push(path);\n    }\n  };\n  walk(obj);\n  return list;\n};\n\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn: typeof newProxy) => {\n  newProxy = fn;\n};\n", "// Credits: https://github.com/pmndrs/valtio\n\nimport { getUntracked, markToTrack } from \"proxy-compare\"\n\nconst isDev = process.env.NODE_ENV !== \"production\"\nconst isObject = (x: unknown): x is object => typeof x === \"object\" && x !== null\n\ntype AsRef = { $$valtioRef: true }\n\ntype ProxyObject = object\n\ntype Path = (string | symbol)[]\ntype Op =\n  | [op: \"set\", path: Path, value: unknown, prevValue: unknown]\n  | [op: \"delete\", path: Path, prevValue: unknown]\n  | [op: \"resolve\", path: Path, value: unknown]\n  | [op: \"reject\", path: Path, error: unknown]\ntype Listener = (op: Op, nextVersion: number) => void\n\ntype AnyFunction = (...args: any[]) => any\n\nexport type Snapshot<T> = T extends AnyFunction\n  ? T\n  : T extends AsRef\n    ? T\n    : T extends Promise<any>\n      ? Awaited<T>\n      : {\n          readonly [K in keyof T]: Snapshot<T[K]>\n        }\n\ntype HandlePromise = <P extends Promise<any>>(promise: P) => Awaited<P>\n\ntype CreateSnapshot = <T extends object>(target: T, version: number, handlePromise?: HandlePromise) => T\n\ntype RemoveListener = () => void\ntype AddListener = (listener: Listener) => RemoveListener\n\ntype ProxyState = readonly [\n  target: object,\n  ensureVersion: (nextCheckVersion?: number) => number,\n  createSnapshot: CreateSnapshot,\n  addListener: AddListener,\n]\n\n// shared state\nconst proxyStateMap = new WeakMap<ProxyObject, ProxyState>()\nconst refSet = new WeakSet()\n\nconst buildProxyFunction = (\n  objectIs = Object.is,\n\n  newProxy = <T extends object>(target: T, handler: ProxyHandler<T>): T => new Proxy(target, handler),\n\n  canProxy = (x: unknown) =>\n    isObject(x) &&\n    !refSet.has(x) &&\n    (Array.isArray(x) || !(Symbol.iterator in x)) &&\n    !(x instanceof WeakMap) &&\n    !(x instanceof WeakSet) &&\n    !(x instanceof Error) &&\n    !(x instanceof Number) &&\n    !(x instanceof Date) &&\n    !(x instanceof String) &&\n    !(x instanceof RegExp) &&\n    !(x instanceof ArrayBuffer),\n\n  defaultHandlePromise = <P extends Promise<any>>(\n    promise: P & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\"\n      value?: Awaited<P>\n      reason?: unknown\n    },\n  ) => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value as Awaited<P>\n      case \"rejected\":\n        throw promise.reason\n      default:\n        throw promise\n    }\n  },\n\n  snapCache = new WeakMap<object, [version: number, snap: unknown]>(),\n\n  createSnapshot: CreateSnapshot = <T extends object>(\n    target: T,\n    version: number,\n    handlePromise: HandlePromise = defaultHandlePromise,\n  ): T => {\n    const cache = snapCache.get(target)\n    if (cache?.[0] === version) {\n      return cache[1] as T\n    }\n    const snap: any = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))\n    markToTrack(snap, true) // mark to track\n    snapCache.set(target, [version, snap])\n    Reflect.ownKeys(target).forEach((key) => {\n      const value = Reflect.get(target, key)\n      if (refSet.has(value as object)) {\n        markToTrack(value as object, false) // mark not to track\n        snap[key] = value\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value)\n          },\n        })\n      } else if (proxyStateMap.has(value as object)) {\n        snap[key] = snapshot(value as object, handlePromise)\n      } else {\n        snap[key] = value\n      }\n    })\n    return Object.freeze(snap)\n  },\n\n  proxyCache = new WeakMap<object, ProxyObject>(),\n\n  versionHolder = [1, 1] as [number, number],\n\n  proxyFunction = <T extends object>(initialObject: T): T => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\")\n    }\n    const found = proxyCache.get(initialObject) as T | undefined\n    if (found) {\n      return found\n    }\n    let version = versionHolder[0]\n    const listeners = new Set<Listener>()\n    const notifyUpdate = (op: Op, nextVersion = ++versionHolder[0]) => {\n      if (version !== nextVersion) {\n        version = nextVersion\n        listeners.forEach((listener) => listener(op, nextVersion))\n      }\n    }\n    let checkVersion = versionHolder[1]\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion\n        propProxyStates.forEach(([propProxyState]) => {\n          const propVersion = propProxyState[1](nextCheckVersion)\n          if (propVersion > version) {\n            version = propVersion\n          }\n        })\n      }\n      return version\n    }\n    const createPropListener =\n      (prop: string | symbol): Listener =>\n      (op, nextVersion) => {\n        const newOp: Op = [...op]\n        newOp[1] = [prop, ...(newOp[1] as Path)]\n        notifyUpdate(newOp, nextVersion)\n      }\n    const propProxyStates = new Map<string | symbol, readonly [ProxyState, RemoveListener?]>()\n    const addPropListener = (prop: string | symbol, propProxyState: ProxyState) => {\n      if (isDev && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\")\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop))\n        propProxyStates.set(prop, [propProxyState, remove])\n      } else {\n        propProxyStates.set(prop, [propProxyState])\n      }\n    }\n    const removePropListener = (prop: string | symbol) => {\n      const entry = propProxyStates.get(prop)\n      if (entry) {\n        propProxyStates.delete(prop)\n        entry[1]?.()\n      }\n    }\n    const addListener = (listener: Listener) => {\n      listeners.add(listener)\n      if (listeners.size === 1) {\n        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n          if (isDev && prevRemove) {\n            throw new Error(\"remove already exists\")\n          }\n          const remove = propProxyState[3](createPropListener(prop))\n          propProxyStates.set(prop, [propProxyState, remove])\n        })\n      }\n      const removeListener = () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          propProxyStates.forEach(([propProxyState, remove], prop) => {\n            if (remove) {\n              remove()\n              propProxyStates.set(prop, [propProxyState])\n            }\n          })\n        }\n      }\n      return removeListener\n    }\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject))\n    const handler: ProxyHandler<T> = {\n      deleteProperty(target: T, prop: string | symbol) {\n        const prevValue = Reflect.get(target, prop)\n        removePropListener(prop)\n        const deleted = Reflect.deleteProperty(target, prop)\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue])\n        }\n        return deleted\n      },\n      set(target: T, prop: string | symbol, value: any, receiver: object) {\n        const hasPrevValue = Reflect.has(target, prop)\n        const prevValue = Reflect.get(target, prop, receiver)\n        if (\n          hasPrevValue &&\n          (objectIs(prevValue, value) || (proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value))))\n        ) {\n          return true\n        }\n        removePropListener(prop)\n        if (isObject(value)) {\n          value = getUntracked(value) || value\n        }\n        let nextValue = value\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n          // do nothing\n        } else if (value instanceof Promise) {\n          value\n            .then((v) => {\n              value.status = \"fulfilled\"\n              value.value = v\n              notifyUpdate([\"resolve\", [prop], v])\n            })\n            .catch((e) => {\n              value.status = \"rejected\"\n              value.reason = e\n              notifyUpdate([\"reject\", [prop], e])\n            })\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value)\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue)\n          if (childProxyState) {\n            addPropListener(prop, childProxyState)\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver)\n        notifyUpdate([\"set\", [prop], value, prevValue])\n        return true\n      },\n    }\n    const proxyObject = newProxy(baseObject, handler)\n    proxyCache.set(initialObject, proxyObject)\n    const proxyState: ProxyState = [baseObject, ensureVersion, createSnapshot, addListener]\n    proxyStateMap.set(proxyObject, proxyState)\n    Reflect.ownKeys(initialObject).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key) as PropertyDescriptor\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc)\n      } else {\n        proxyObject[key as keyof T] = initialObject[key as keyof T]\n      }\n    })\n    return proxyObject\n  },\n) =>\n  [\n    // public functions\n    proxyFunction,\n    // shared state\n    proxyStateMap,\n    refSet,\n    // internal things\n    objectIs,\n    newProxy,\n    canProxy,\n    defaultHandlePromise,\n    snapCache,\n    createSnapshot,\n    proxyCache,\n    versionHolder,\n  ] as const\n\nconst [proxyFunction] = buildProxyFunction()\n\nexport function proxy<T extends object>(initialObject: T = {} as T): T {\n  return proxyFunction(initialObject)\n}\n\nexport function getVersion(proxyObject: unknown): number | undefined {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  return proxyState?.[1]()\n}\n\nexport function subscribe<T extends object>(\n  proxyObject: T,\n  callback: (ops: Op[]) => void,\n  notifyInSync?: boolean,\n): () => void {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  let promise: Promise<void> | undefined\n  const ops: Op[] = []\n  const addListener = (proxyState as ProxyState)[3]\n  let isListenerActive = false\n  const listener: Listener = (op) => {\n    ops.push(op)\n    if (notifyInSync) {\n      callback(ops.splice(0))\n      return\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = undefined\n        if (isListenerActive) {\n          callback(ops.splice(0))\n        }\n      })\n    }\n  }\n  const removeListener = addListener(listener)\n  isListenerActive = true\n  return () => {\n    isListenerActive = false\n    removeListener()\n  }\n}\n\nexport function snapshot<T extends object>(proxyObject: T, handlePromise?: HandlePromise): Snapshot<T> {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState as ProxyState\n  return createSnapshot(target, ensureVersion(), handlePromise) as Snapshot<T>\n}\n\nexport function ref<T extends object>(obj: T): T & AsRef {\n  refSet.add(obj)\n  return obj as T & AsRef\n}\n", "import { proxy, snapshot, type Snapshot } from \"./proxy\"\n\nexport function proxyWithComputed<T extends object, U extends object>(\n  initialObject: T,\n  computedFns: {\n    [K in keyof U]:\n      | ((snap: Snapshot<T>) => U[K])\n      | {\n          get: (snap: Snapshot<T>) => U[K]\n          set?: (state: T, newValue: U[K]) => void\n        }\n  },\n) {\n  const keys = Object.keys(computedFns) as (keyof U)[]\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\")\n    }\n    const computedFn = computedFns[key]\n    const { get, set } = (typeof computedFn === \"function\" ? { get: computedFn } : computedFn) as {\n      get: (snap: Snapshot<T>) => U[typeof key]\n      set?: (state: T, newValue: U[typeof key]) => void\n    }\n    const desc: PropertyDescriptor = {}\n    desc.get = () => get(snapshot(proxyObject))\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue)\n    }\n    Object.defineProperty(initialObject, key, desc)\n  })\n  const proxyObject = proxy(initialObject) as T & U\n  return proxyObject\n}\n", "function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nexport function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n", "export { proxy, ref, snapshot, subscribe } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n", "import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n", "import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n", "import { ref, snapshot, subscribe } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  hasProp,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Map<string, VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n\n    this.initialContext = snapshot(this.state.context)\n\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  private get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n    this.state.tags = []\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    const { watch } = this.config\n    if (!watch) return\n\n    let prev = snapshot(this.state.context)\n\n    const cleanup = subscribe(this.state.context, () => {\n      const next = snapshot(this.state.context)\n\n      for (const [key, fn] of Object.entries(watch)) {\n        const isEqual = this.options.compareFns?.[key] ?? Object.is\n        if (isEqual(prev[key], next[key])) continue\n        this.executeActions(fn, this.state.event as TEvent)\n      }\n\n      prev = next\n    })\n\n    this.contextWatchers.add(cleanup)\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private stopActivity = (key: string) => {\n    if (!this.state.value) return\n    const cleanups = this.activityEvents.get(this.state.value)\n    cleanups?.get(key)?.() // cleanup\n    cleanups?.delete(key) // remove from map\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, key: string, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Map([[key, cleanup]]))\n    } else {\n      this.activityEvents.get(state)?.set(key, cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, compact(context))\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getAfterActions = (transition: S.Transitions<TContext, TState, TEvent>, delay?: number) => {\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, this.state.event)\n          this.performStateChangeEffects(this.state.value!, next, this.state.event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = this.state.event\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n\n      if (!transition) return\n\n      if (!hasProp(transition, \"delay\")) {\n        throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`)\n      }\n\n      const determineDelay = determineDelayFn((transition as any).delay, this.delayMap)\n      const __delay = determineDelay(this.contextSnapshot, event)\n\n      const actions = this.getAfterActions(transition, __delay)\n\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n\n      return { entries, exits }\n    }\n\n    if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n\n        const determineDelay = determineDelayFn(delay, this.delayMap)\n        const __delay = determineDelay(this.contextSnapshot, event)\n\n        const actions = this.getAfterActions(transition, __delay)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        const key = isString(activity) ? activity : activity.name || uuid()\n        this.addActivityCleanup(state ?? this.state.value, key, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, this.state.event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, this.state.event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n", "import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : []\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: (initialTags ?? []) as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n", "import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n", "import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n", "import { callAll } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim?.())\n    .filter(Boolean)\n    .join(\" \")\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nconst eventRegex = /^on[A-Z]/\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (eventRegex.test(key) && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(result[key], props[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {})\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n", "import type { JSX } from \"./jsx\"\n\ntype Dict<T = any> = Record<string, T>\n\ntype Booleanish = boolean | \"true\" | \"false\"\n\ntype DataAttr = {\n  \"data-selected\"?: Booleanish\n  \"data-expanded\"?: Booleanish\n  \"data-highlighted\"?: Booleanish\n  \"data-readonly\"?: Booleanish\n  \"data-indeterminate\"?: Booleanish\n  \"data-invalid\"?: Booleanish\n  \"data-hover\"?: Booleanish\n  \"data-active\"?: Booleanish\n  \"data-focus\"?: Booleanish\n  \"data-disabled\"?: Booleanish\n  \"data-open\"?: Booleanish\n  \"data-checked\"?: Booleanish\n  \"data-pressed\"?: Booleanish\n  \"data-complete\"?: Booleanish\n  \"data-empty\"?: Booleanish\n  \"data-placeholder-shown\"?: Booleanish\n  \"data-half\"?: Booleanish\n  \"data-scope\"?: string\n\n  \"data-uid\"?: string\n  \"data-name\"?: string\n  \"data-ownedby\"?: string\n  \"data-type\"?: string\n  \"data-valuetext\"?: string\n  \"data-placement\"?: string\n  \"data-controls\"?: string\n  \"data-part\"?: string\n  \"data-label\"?: string\n  \"data-state\"?: string | null\n  \"data-value\"?: string | number\n\n  \"data-orientation\"?: \"horizontal\" | \"vertical\"\n\n  \"data-count\"?: number\n  \"data-index\"?: number\n} & {\n  [key in `data-${string}`]?: string | number | Booleanish\n}\n\nexport type PropTypes<T = Dict> = Record<\n  \"button\" | \"label\" | \"input\" | \"textarea\" | \"img\" | \"output\" | \"element\" | \"select\" | \"style\" | \"circle\" | \"svg\",\n  T\n>\n\nexport type NormalizeProps<T extends PropTypes> = {\n  [K in keyof T]: (props: K extends keyof JSX.IntrinsicElements ? DataAttr & JSX.IntrinsicElements[K] : never) => T[K]\n} & {\n  element(props: DataAttr & JSX.HTMLAttributes<HTMLElement> & Record<string, any>): T[\"element\"]\n  style: JSX.CSSProperties\n}\n\nexport function createNormalizer<T extends PropTypes>(fn: (props: Dict) => Dict): NormalizeProps<T> {\n  return new Proxy({} as any, {\n    get() {\n      return fn\n    },\n  })\n}\n", "type StrictKeys<K extends (keyof T)[], T> = K extends (keyof T)[]\n  ? [keyof T] extends [K[number]]\n    ? unknown\n    : `Missing required keys: ${Exclude<keyof T, K[number]>}`\n  : never\n\nexport const createProps =\n  <T extends Record<never, never>>() =>\n  <K extends (keyof T)[]>(props: K & StrictKeys<K, T>) =>\n    Array.from(new Set(props))\n", "import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"carousel\").parts(\n  \"root\",\n  \"viewport\",\n  \"itemGroup\",\n  \"item\",\n  \"nextTrigger\",\n  \"prevTrigger\",\n  \"indicatorGroup\",\n  \"indicator\",\n)\n\nexport const parts = anatomy.build()\n", "import { dataAttr, isDom } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./carousel.anatomy\"\nimport { dom } from \"./carousel.dom\"\nimport type { MachineApi, Send, IndicatorProps, ItemProps, State, ItemState } from \"./carousel.types\"\nimport { getSlidesInView } from \"./utils/get-slide-in-view\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const canScrollNext = state.context.canScrollNext\n  const canScrollPrev = state.context.canScrollPrev\n  const isHorizontal = state.context.isHorizontal\n  const isAutoplay = state.matches(\"autoplay\")\n\n  const activeSnap = state.context.scrollSnaps[state.context.index]\n  const slidesInView = isDom() ? getSlidesInView(state.context)(activeSnap) : []\n\n  function getItemState(props: ItemProps): ItemState {\n    const { index } = props\n    return {\n      valueText: `Slide ${index + 1}`,\n      isCurrent: index === state.context.index,\n      isNext: index === state.context.index + 1,\n      isPrevious: index === state.context.index - 1,\n      isInView: slidesInView.includes(index),\n    }\n  }\n\n  return {\n    index: state.context.index,\n    scrollProgress: state.context.scrollProgress,\n    isAutoplay,\n    canScrollNext,\n    canScrollPrev,\n\n    scrollTo(index, jump) {\n      send({ type: \"GOTO\", index, jump })\n    },\n\n    scrollToNext() {\n      send(\"NEXT\")\n    },\n\n    scrollToPrevious() {\n      send(\"PREV\")\n    },\n\n    getItemState: getItemState,\n\n    play() {\n      send(\"PLAY\")\n    },\n\n    pause() {\n      send(\"PAUSE\")\n    },\n\n    rootProps: normalize.element({\n      ...parts.root.attrs,\n      id: dom.getRootId(state.context),\n      role: \"region\",\n      \"aria-roledescription\": \"carousel\",\n      \"data-orientation\": state.context.orientation,\n      dir: state.context.dir,\n      \"aria-label\": \"Carousel\",\n      style: {\n        \"--slide-spacing\": state.context.spacing,\n        \"--slide-size\": `calc(100% / ${state.context.slidesPerView} - var(--slide-spacing))`,\n      },\n    }),\n\n    viewportProps: normalize.element({\n      ...parts.viewport.attrs,\n      dir: state.context.dir,\n      id: dom.getViewportId(state.context),\n      \"data-orientation\": state.context.orientation,\n    }),\n\n    itemGroupProps: normalize.element({\n      ...parts.itemGroup.attrs,\n      id: dom.getItemGroupId(state.context),\n      \"data-orientation\": state.context.orientation,\n      dir: state.context.dir,\n      style: {\n        display: \"flex\",\n        flexDirection: isHorizontal ? \"row\" : \"column\",\n        [isHorizontal ? \"height\" : \"width\"]: \"auto\",\n        gap: \"var(--slide-spacing)\",\n        transform: state.context.translateValue,\n        transitionProperty: \"transform\",\n        willChange: \"transform\",\n        transitionTimingFunction: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n        transitionDuration: \"0.3s\",\n      },\n    }),\n\n    getItemProps(props) {\n      const { index } = props\n      const sliderState = getItemState(props)\n\n      return normalize.element({\n        ...parts.item.attrs,\n        id: dom.getItemId(state.context, index),\n        dir: state.context.dir,\n        \"data-current\": dataAttr(sliderState.isCurrent),\n        \"data-inview\": dataAttr(sliderState.isInView),\n        role: \"group\",\n        \"aria-roledescription\": \"slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-label\": sliderState.valueText,\n        style: {\n          position: \"relative\",\n          flex: \"0 0 var(--slide-size)\",\n          [isHorizontal ? \"minWidth\" : \"minHeight\"]: \"0px\",\n        },\n      })\n    },\n\n    prevTriggerProps: normalize.button({\n      ...parts.prevTrigger.attrs,\n      id: dom.getPrevTriggerId(state.context),\n      type: \"button\",\n      tabIndex: -1,\n      disabled: !canScrollPrev,\n      dir: state.context.dir,\n      \"aria-label\": \"Previous Slide\",\n      \"data-orientation\": state.context.orientation,\n      \"aria-controls\": dom.getItemGroupId(state.context),\n      onClick() {\n        send(\"PREV\")\n      },\n    }),\n\n    nextTriggerProps: normalize.button({\n      ...parts.nextTrigger.attrs,\n      dir: state.context.dir,\n      id: dom.getNextTriggerId(state.context),\n      type: \"button\",\n      tabIndex: -1,\n      \"aria-label\": \"Next Slide\",\n      \"data-orientation\": state.context.orientation,\n      \"aria-controls\": dom.getItemGroupId(state.context),\n      disabled: !canScrollNext,\n      onClick() {\n        send(\"NEXT\")\n      },\n    }),\n\n    indicatorGroupProps: normalize.element({\n      ...parts.indicatorGroup.attrs,\n      dir: state.context.dir,\n      id: dom.getIndicatorGroupId(state.context),\n      \"data-orientation\": state.context.orientation,\n    }),\n\n    getIndicatorProps(props: IndicatorProps) {\n      const { index, readOnly } = props\n      return normalize.button({\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        id: dom.getIndicatorId(state.context, index),\n        type: \"button\",\n        \"data-orientation\": state.context.orientation,\n        \"data-index\": index,\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-current\": dataAttr(index === state.context.index),\n        onClick() {\n          if (readOnly) return\n          send({ type: \"GOTO\", index })\n        },\n      })\n    },\n  }\n}\n", "import { createScope, queryAll } from \"@zag-js/dom-query\"\nimport type { MachineContext as Ctx } from \"./carousel.types\"\n\nexport const dom = createScope({\n  getRootId: (ctx: Ctx) => ctx.ids?.root ?? `carousel:${ctx.id}`,\n  getViewportId: (ctx: Ctx) => ctx.ids?.viewport ?? `carousel:${ctx.id}:viewport`,\n  getItemId: (ctx: Ctx, index: number) => ctx.ids?.slide?.(index) ?? `carousel:${ctx.id}:slide:${index}`,\n  getItemGroupId: (ctx: Ctx) => ctx.ids?.slideGroup ?? `carousel:${ctx.id}:slide-group`,\n  getNextTriggerId: (ctx: Ctx) => ctx.ids?.nextSlideTrigger ?? `carousel:${ctx.id}:next-slide-trigger`,\n  getPrevTriggerId: (ctx: Ctx) => ctx.ids?.prevSlideTrigger ?? `carousel:${ctx.id}:prev-slide-trigger`,\n  getIndicatorGroupId: (ctx: Ctx) => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`,\n  getIndicatorId: (ctx: Ctx, index: number) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`,\n\n  getRootEl: (ctx: Ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getViewportEl: (ctx: Ctx) => dom.getById(ctx, dom.getViewportId(ctx)),\n  getSlideGroupEl: (ctx: Ctx) => dom.getById(ctx, dom.getItemGroupId(ctx)),\n  getSlideEls: (ctx: Ctx) => queryAll(dom.getSlideGroupEl(ctx), `[data-part=item]`),\n})\n", "export function getLimit(min: number, max: number) {\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  return {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n}\n", "import { isNumber } from \"@zag-js/utils\"\n\nexport type AlignmentOptionType = \"start\" | \"center\" | \"end\" | number\n\nexport const getAlignment = (align: AlignmentOptionType, containerSize: number) => {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return containerSize - n\n  }\n\n  function percent(): number {\n    return containerSize * Number(align)\n  }\n\n  return (n: number) => {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n}\n", "import { isNumber } from \"@zag-js/utils\"\nimport type { MachineContext } from \"../carousel.types\"\n\nexport function getSlidesToScroll(\n  containerSize: number,\n  slideSizesWithGaps: number[],\n  slidesPerView: MachineContext[\"slidesPerView\"],\n) {\n  function byNumber<T>(array: T[], groupSize: number): T[][] {\n    return Array.from(array.keys())\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<T>(array: T[]): T[][] {\n    return Array.from(array.keys())\n      .reduce((groups: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(groups.at(-1), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > containerSize ? groups.concat(i) : groups\n      }, [])\n      .map((start, i, groups) => array.slice(start, groups[i + 1]))\n  }\n\n  return function groupSlides<T>(array: T[]): T[][] {\n    return isNumber(slidesPerView) ? byNumber(array, slidesPerView) : bySize(array)\n  }\n}\n", "import type { MachineContext } from \"../carousel.types\"\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function getSlideSizes(ctx: MachineContext): SlideSizesType {\n  const startGap = measureStartGap()\n\n  function measureStartGap(): number {\n    if (!ctx.containerRect) return 0\n    const slideRect = ctx.slideRects[0]\n    return Math.abs(ctx.containerRect[ctx.startEdge] - slideRect[ctx.startEdge])\n  }\n\n  function measureWithGaps(): number[] {\n    return ctx.slideRects.map((rect, index, rects) => {\n      const isFirst = !index\n      if (isFirst) return Math.abs(slideSizes[index] + startGap)\n\n      const isLast = index === rects.length - 1\n      if (isLast) return Math.abs(slideSizes[index])\n\n      return Math.abs(rects[index + 1][ctx.startEdge] - rect[ctx.startEdge])\n    })\n  }\n\n  const slideSizes = ctx.slideRects.map((slideRect) => {\n    return ctx.isVertical ? slideRect.height : slideRect.width\n  })\n  const slideSizesWithGaps = measureWithGaps()\n\n  return {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n}\n", "import type { MachineContext } from \"../carousel.types\"\nimport { getAlignment } from \"./get-alignment\"\nimport { getLimit } from \"./get-limit\"\nimport { getSlidesToScroll } from \"./get-slide-groups\"\nimport { getSlideSizes } from \"./get-slide-sizes\"\n\nconst arrayLast = <T>(array: T[]): T => array[arrayLastIndex(array)]\nconst arrayLastIndex = <T>(array: T[]): number => Math.max(0, array.length - 1)\n\nexport function getScrollSnaps(ctx: MachineContext) {\n  const { slideSizes, slideSizesWithGaps } = getSlideSizes(ctx)\n\n  const groupSlides = getSlidesToScroll(ctx.containerSize!, slideSizesWithGaps, ctx.slidesPerView)\n\n  function measureSizes(): number[] {\n    return groupSlides(ctx.slideRects)\n      .map((rects) => arrayLast(rects)[ctx.endEdge] - rects[0][ctx.startEdge])\n      .map(Math.abs)\n  }\n\n  function measureUnaligned(): number[] {\n    return ctx.slideRects\n      .map((slideRect) => ctx.containerRect![ctx.startEdge] - slideRect[ctx.startEdge])\n      .map((snap) => -Math.abs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const measureFn = getAlignment(ctx.align, ctx.containerSize!)\n    const alignments = measureSizes().map(measureFn)\n\n    return groupSlides(snaps)\n      .map((snap) => snap[0])\n      .map((snap, index) => snap + alignments[index])\n  }\n\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n\n  const scrollLimit = getLimit(snaps[snaps.length - 1], snaps[0])\n  const scrollProgress = (snapsAligned[ctx.index] - scrollLimit.max) / -scrollLimit.length\n\n  return {\n    snaps,\n    snapsAligned,\n    slideSizes,\n    slideSizesWithGaps,\n    contentSize,\n    scrollLimit,\n    scrollProgress: Math.abs(scrollProgress),\n  }\n}\n", "import type { MachineContext } from \"../carousel.types\"\nimport { getLimit } from \"./get-limit\"\nimport { getScrollSnaps } from \"./get-scroll-snaps\"\n\ntype Bound = {\n  start: number\n  end: number\n  index: number\n}\n\nconst slideThreshold = 0\n\nexport function getSlidesInView(ctx: MachineContext) {\n  const roundingSafety = 0.5\n  const slideOffsets = [0]\n\n  const { snaps, slideSizes, scrollLimit } = getScrollSnaps(ctx)\n\n  const slideThresholds = slideSizes.map((slideSize) => {\n    const thresholdLimit = getLimit(roundingSafety, slideSize - roundingSafety)\n    return thresholdLimit.constrain(slideSize * slideThreshold)\n  })\n\n  const slideBounds = slideOffsets.reduce((acc: Bound[], offset) => {\n    const bounds = snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + slideThresholds[index] + offset,\n      end: snap + ctx.containerSize - slideThresholds[index] + offset,\n      index,\n    }))\n    return acc.concat(bounds)\n  }, [])\n\n  return (location: number) => {\n    const loc = scrollLimit.constrain(location)\n    return slideBounds.reduce((list: number[], bound) => {\n      const { index, start, end } = bound\n      const inList = list.includes(index)\n      const inView = start < loc && end > loc\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n}\n", "import { createMachine, ref } from \"@zag-js/core\"\nimport { compact, isEqual, nextIndex, prevIndex } from \"@zag-js/utils\"\nimport { dom } from \"./carousel.dom\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./carousel.types\"\nimport { getScrollSnaps } from \"./utils/get-scroll-snaps\"\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"carousel\",\n      initial: \"idle\",\n      context: {\n        index: 0,\n        orientation: \"horizontal\",\n        align: \"start\",\n        loop: false,\n        slidesPerView: 1,\n        spacing: \"0px\",\n        ...ctx,\n        scrollSnaps: [],\n        scrollProgress: 0,\n        containerSize: 0,\n        slideRects: [],\n      },\n\n      watch: {\n        index: [\"setScrollSnaps\"],\n      },\n\n      on: {\n        NEXT: {\n          actions: [\"scrollToNext\"],\n        },\n        PREV: {\n          actions: [\"scrollToPrev\"],\n        },\n        GOTO: {\n          actions: [\"scrollTo\"],\n        },\n        MEASURE_DOM: {\n          actions: [\"measureElements\", \"setScrollSnaps\"],\n        },\n        PLAY: \"autoplay\",\n      },\n\n      states: {\n        idle: {\n          on: {\n            POINTER_DOWN: \"dragging\",\n          },\n        },\n        autoplay: {\n          activities: [\"trackDocumentVisibility\"],\n          every: {\n            2000: [\"scrollToNext\"],\n          },\n          on: {\n            PAUSE: \"idle\",\n          },\n        },\n        dragging: {\n          on: {\n            POINTER_UP: \"idle\",\n            POINTER_MOVE: {\n              actions: [\"setScrollSnaps\"],\n            },\n          },\n        },\n      },\n      activities: [\"trackContainerResize\", \"trackSlideMutation\"],\n      entry: [\"measureElements\", \"setScrollSnaps\"],\n      computed: {\n        isRtl: (ctx) => ctx.dir === \"rtl\",\n        isHorizontal: (ctx) => ctx.orientation === \"horizontal\",\n        isVertical: (ctx) => ctx.orientation === \"vertical\",\n        canScrollNext: (ctx) => ctx.loop || ctx.index < ctx.scrollSnaps.length - 1,\n        canScrollPrev: (ctx) => ctx.loop || ctx.index > 0,\n        startEdge(ctx) {\n          if (ctx.isVertical) return \"top\"\n          return ctx.isRtl ? \"right\" : \"left\"\n        },\n        endEdge(ctx) {\n          if (ctx.isVertical) return \"bottom\"\n          return ctx.isRtl ? \"left\" : \"right\"\n        },\n        translateValue: (ctx) => {\n          const scrollSnap = ctx.scrollSnaps[ctx.index]\n          return ctx.isHorizontal ? `translate3d(${scrollSnap}px, 0, 0)` : `translate3d(0, ${scrollSnap}px, 0)`\n        },\n      },\n    },\n    {\n      activities: {\n        trackSlideMutation(ctx, _evt, { send }) {\n          const slideGroupEl = dom.getSlideGroupEl(ctx)\n          if (!slideGroupEl) return\n          const win = dom.getWin(ctx)\n          const observer = new win.MutationObserver(() => {\n            send({ type: \"MEASURE_DOM\", src: \"mutation\" })\n          })\n          observer.observe(slideGroupEl, { childList: true })\n          return () => {\n            observer.disconnect()\n          }\n        },\n        trackContainerResize(ctx, _evt, { send }) {\n          const slideGroupEl = dom.getSlideGroupEl(ctx)\n          if (!slideGroupEl) return\n          const win = dom.getWin(ctx)\n          const observer = new win.ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n              if (entry.target === slideGroupEl) {\n                send({ type: \"MEASURE_DOM\", src: \"resize\" })\n              }\n            })\n          })\n          observer.observe(slideGroupEl)\n          return () => {\n            observer.disconnect()\n          }\n        },\n        trackDocumentVisibility(ctx, _evt, { send }) {\n          const doc = dom.getDoc(ctx)\n          const onVisibilityChange = () => {\n            if (doc.visibilityState !== \"visible\") {\n              send({ type: \"PAUSE\", src: \"document-hidden\" })\n            }\n          }\n          doc.addEventListener(\"visibilitychange\", onVisibilityChange)\n          return () => {\n            doc.removeEventListener(\"visibilitychange\", onVisibilityChange)\n          }\n        },\n      },\n      guards: {\n        loop: (ctx) => ctx.loop,\n        isLastSlide: (ctx) => ctx.index === ctx.slideRects.length - 1,\n        isFirstSlide: (ctx) => ctx.index === 0,\n      },\n      actions: {\n        scrollToNext(ctx) {\n          const index = nextIndex(ctx.slideRects, ctx.index)\n          set.index(ctx, index)\n        },\n        scrollToPrev(ctx) {\n          const index = prevIndex(ctx.slideRects, ctx.index)\n          set.index(ctx, index)\n        },\n        setScrollSnaps(ctx) {\n          const { snapsAligned, scrollProgress } = getScrollSnaps(ctx)\n          ctx.scrollSnaps = snapsAligned\n          ctx.scrollProgress = scrollProgress\n        },\n        scrollTo(ctx, evt) {\n          const index = Math.max(0, Math.min(evt.index, ctx.slideRects.length - 1))\n          set.index(ctx, index)\n        },\n        measureElements,\n      },\n    },\n  )\n}\n\nconst measureElements = (ctx: MachineContext) => {\n  const slideGroupEl = dom.getSlideGroupEl(ctx)\n  if (!slideGroupEl) return\n  ctx.containerRect = ref(slideGroupEl.getBoundingClientRect())\n  ctx.containerSize = ctx.isHorizontal ? ctx.containerRect.width : ctx.containerRect.height\n  ctx.slideRects = ref(dom.getSlideEls(ctx).map((slide) => slide.getBoundingClientRect()))\n}\n\nconst invoke = {\n  change: (ctx: MachineContext) => {\n    ctx.onIndexChange?.({ index: ctx.index })\n  },\n}\n\nconst set = {\n  index: (ctx: MachineContext, index: number) => {\n    if (isEqual(ctx.index, index)) return\n    ctx.index = index\n    invoke.change(ctx)\n  },\n}\n", "import { createProps } from \"@zag-js/types\"\nimport { createSplitProps } from \"@zag-js/utils\"\nimport type { IndicatorProps, UserDefinedContext } from \"./carousel.types\"\n\nexport const props = createProps<UserDefinedContext>()([\n  \"align\",\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"index\",\n  \"loop\",\n  \"onIndexChange\",\n  \"orientation\",\n  \"slidesPerView\",\n  \"spacing\",\n])\nexport const splitProps = createSplitProps<Partial<UserDefinedContext>>(props)\n\nexport const indicatorProps = createProps<IndicatorProps>()([\"index\", \"readOnly\"])\nexport const splitIndicatorProps = createSplitProps<IndicatorProps>(indicatorProps)\n"],
  "mappings": "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",
  "names": ["parts", "query", "next", "last", "props", "TRACK_MEMO_SYMBOL", "Symbol", "GET_ORIGINAL_SYMBOL", "getProto", "Object", "getPrototypeOf", "objectsToTrack", "WeakMap", "isObjectToTrack", "obj", "has", "get", "prototype", "Array", "getUntracked", "obj", "isObjectToTrack", "GET_ORIGINAL_SYMBOL", "markToTrack", "mark", "objectsToTrack", "set", "proxyFunction", "e", "set", "isDev", "isObject", "isNumber", "compact", "isPlainObject", "c", "_b", "_a", "isNumber", "event", "isObject", "isEqual", "state", "compact", "options", "determineDelay", "delay", "isDev", "props", "s", "isNumber", "props", "ctx", "set", "splitProps"]
}
